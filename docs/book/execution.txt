== Waf projects and commands

The +waf+ script is meant to build software projects, and is of little use when taken alone. This chapter describes what is necessary to set up a waf project and how to use the +waf+ script.

=== Waf commands

==== Declaring Waf commands

Waf projects use description files having the name +wscript+ which are python scripts in disguise. They contain functions and variables that are used by Waf. Here is a very simple example of a wscript file:

// execution_hello
[source,python]
---------------
#! /usr/bin/env python
# encoding: utf-8
def hello(ctx):
    print('hello world')
---------------

And here is how to have +waf+ call the function hello:

[source,shishell]
---------------
$ waf hello
hello world
'hello' finished successfully (0.001s)
---------------

In +waf+ terms, the function hello is called a _waf command_, and the parameter +ctx+ is a _waf context_. The context parameters are used to share data between scripts, but this is going to be described in details in the next chapters.

==== Chaining Waf commands

Several commands may be declared in the same wscript file:

// execution ping
[source,python]
---------------
def ping(ctx):
	print(' ping!')

def pong(ctx):
	print(' pong!')
---------------

And may be chained for execution by Waf:

[source,shishell]
---------------
$ waf ping pong ping
 ping!
'ping' finished successfully (0.000s)
 pong!
'pong' finished successfully (0.000s)
 ping!
'ping' finished successfully (0.000s)
---------------

==== The 'configure' command

Large projects typically have many wscript files spread over various folders and may be divided in subprojects. Calling +waf+ in some folder may then execute unexpected commands and produce confusing errors. To help structure waf projects, the following concepts are now being introduced:

. Project directory: directory containing the source files that will be packaged and redistributed to other developers or to end users
. Build directory: directory containing the files generated by the project (configuration sets, build files, logs, etc)
. System files: files and folders which do not belong to the project (operating system files, etc)

A special command called 'configure' is used to gather and store the information about these folders.

We will now create a new Waf project in the folder '/tmp/smallproject' with the following wscript file:

[source,python]
---------------
top = '.' <1>
out = 'build' <2>

def configure(ctx): <3>
	print('→ configuring the project')
---------------

<1> string representing the project directory. In general, top is set to '.', except for some proprietary projects where the wscript cannot be added to the top-level, top may be set to '../..' or even some other folder such as '/checkout/perforce/project'
<2> string representing the build directory. In general, it is set to 'build', except for some proprietary projects where the build directory may be set to an absolute path such as '/tmp/build'. It is important to be able to remove the build directory safely, so it should never be given as '.' or '..'.
<3> the 'configure' command declaration is mandatory

The execution output will be the following:

[source,shishell]
---------------
$ cd /tmp/smallproject <1>
$ tree
.
`-- wscript

$ waf configure <2>
→ configuring the project
'configure' finished successfully (0.021s)

$ tree -a
.
|-- build_directory/ <3>
|   |-- c4che/ <4>
|   |   |-- build.config.py <5>
|   |   `-- default.cache.py <6>
|   `-- config.log <7>
|--.lock-build <8>
`-- wscript
---------------

<1> To configure the project, change to the directory containing the top-level project file
<2> The execution is called by calling `waf configure`
<3> The build directory was created
<4> The configuration data is stored in the folder 'c4che/'
<5> The command-line options and environment variables in use are stored in this file
<6> The user configuration set is stored in this file
<7> Configuration log (duplicate of the output generated during the configuration)
<8> Hiden file pointing at the relevant project file and build directory

NOTE: +waf configure+ is called from the directory containing the wscript file

==== Splitting a project into several folders

Although a Waf project must contain a top-level wscript file, the contents may be split into several sub-project files. We will now illustrate this concept on a small project:

[source,shishell]
---------------
.
|-- src
|   `-- wscript
`-- wscript
---------------

The commands in the top-level wscript will call the same commands from a subproject wscript file by calling a context method named 'recurse'.

[source,python]
---------------
top = '.'
out = 'build_directory'

def configure(ctx):
	print('→ configure from the top-level')
	ctx.recurse('src')

def ping(ctx):
	print('→ ping from the top-level')
	ctx.recurse('src')
---------------

Since the folder 'src' is not meant to be redistributed as a standalone project, it is not necessary to duplicate the variables _top_ and _out_.

[source,python]
---------------
def configure(ctx):
	print('→ configure from src')

def ping(ctx):
	print('→ ping from src')
---------------

Upon execution, the results will be:

[source,shishell]
---------------
$ cd /tmp/smallproject

$ waf configure ping
→ configure from the top-level
→ configure from src
'configure' finished successfully (0.080s)
→ ping from the top-level
→ ping from src
'ping' finished successfully (0.009s)
---------------


=== The 'build' commands

==== Building, cleaning, installing and uninstalling a project

The 'build' command is used for building the actual software. Starting again from the project file '/tmp/smallfolder/wscript':

[source,python]
---------------
top = '.'
out = 'build_directory'

def configure(ctx):
	print('→ configure from the top-level')

def build(ctx):
	print('building the software')
---------------

Without surprise, the execution output will look like the following:

[source,shishell]
---------------
$ cd /tmp/smallproject

$ waf
Project not configured (run 'waf configure' first)

$ waf configure
→ configure from the top-level
'configure' finished successfully (0.001s)

$ waf build
Waf: Entering directory `/tmp/smallproject/build_directory'
building the software
Waf: Leaving directory `/tmp/smallproject/build_directory'
'build' finished successfully (0.004s)
---------------

Since the command `waf build` is executed very often, a shortcut is provided to call it implicitly:

[source,shishell]
---------------
$ waf
Waf: Entering directory `/tmp/smallproject/build_directory'
building the software
Waf: Leaving directory `/tmp/smallproject/build_directory'
---------------

The Waf commands +build+, +clean+, +install+, +uninstall+ are shortcuts for calling `waf build` with different internal options. They all require the presence of the _build_ function in the scripts.

[source,shishell]
---------------
$ waf build install uninstall clean
Waf: Entering directory `/tmp/smallproject/build_directory'
building the software
Waf: Leaving directory `/tmp/smallproject/build_directory'
'build' finished successfully (0.004s)
Waf: Entering directory `/tmp/smallproject/build_directory'
building the software
Waf: Leaving directory `/tmp/smallproject/build_directory'
'install' finished successfully (0.003s)
Waf: Entering directory `/tmp/smallproject/build_directory'
building the software
Waf: Leaving directory `/tmp/smallproject/build_directory'
'uninstall' finished successfully (0.002s)
building the software
'clean' finished successfully (0.002s)
---------------

The meaning of the commands is the following:

. +build:+ process the source code to create the object files
. +clean:+ remove the object files that were created during a build (unlike distclean, do not remove the configuration)
. +install:+ check that all object files have been generated and copy them on the system (programs, libraries, data files, etc)
. +uninstall:+ undo the installation, remove the object files from the system without touching the ones in the build directory
. +list:+ list the task generators in the build section (to use with waf --targets=name)
. +step:+ force the rebuild of particular files for debugging purposes

Object file creation and installation will be detailed in the next chapters.

=== More predefined commands

==== Cleaning up a project

Waf itself comes with a predefined command called _distclean_ which removes the build directory and the lock file. After calling cleaning a project, it is necessary to configure it once again.

[source,shishell]
---------------
$ waf configure
→ configuring the project
'configure' finished successfully (0.001s)

$ waf ping
 ping!
'ping' finished successfully (0.000s)

$ waf distclean
'distclean' finished successfully (0.001s)

$ waf ping
Project not configured (run 'waf configure' first)
---------------

It is possible to override the behaviour of 'distclean' by redefining it in the wscript file. For example, the following will cause it to avoid removing the build files.

[source,python]
---------------
top = '.'
out = 'build_directory'

def configure(ctx):
	print('→ configuring the project')

def distclean(ctx):
	print(' Not cleaning anything!')
---------------

Upon execution:

[source,shishell]
---------------
$ waf distclean
 not cleaning anything!
'distclean' finished successfully (0.000s)
---------------

==== Packaging the project sources

The command 'dist' is another predefined utility which is used to create an archive of the project. By using the script presented previously:

[source,python]
---------------
top = '.'
out = 'build_directory'

def configure(ctx):
	print('→ configuring the project')
---------------

Execute the command 'dist' to get:

[source,shishell]
---------------
$ waf configure
→ configuring the project
'configure' finished successfully (0.001s)

$ waf dist
New archive created: noname-1.0.tar.bz2 (sha='c16c97a51b39c7e5bee35bb6d932a12e2952f2f8')
'dist' finished successfully (0.091s)
---------------

By default, the project name and version are set to 'noname' and '1.0'. To change them, it is necessary to provide two additional variables in the top-level project file:

[source,python]
---------------
APPNAME='webe'
VERSION='2.0'

top = '.'
out = 'build_directory'

def configure(ctx):
	print('→ configuring the project')
---------------

Because the project was configured once, it is not necessary to configure it once again:

[source,shishell]
---------------
$ waf dist
New archive created: webe-2.0.tar.bz2 (sha='7ccc338e2ff99b46d97e5301793824e5941dd2be')
'dist' finished successfully (0.006s)
---------------

The default compression format is http://www.bzip.org/[bzip2]. It may be changed to http://www.gzip.org/[gzip] by using the symbol 'gz':

[source,python]
---------------
from waflib import Scripting
Scripting.g_gz = 'gz'
---------------

Or 'zip' for http://en.wikipedia.org/wiki/ZIP_%28file_format%29[zip] files:

[source,python]
---------------
from waflib import Scripting
Scripting.g_gz = 'zip'
---------------

=== Customizing the command-line options

The Waf script provides various default command-line options, which may be consulted by executing `waf --help`:

[source,shishell]
---------------
$ waf --help
waf [command] [options]

Main commands (example: ./waf build -j4)
  build    : executes the build
  clean    : cleans the project
  configure: configures the project
  dist     : makes a tarball for redistributing the sources
  distcheck: checks if the project compiles (tarball from 'dist')
  distclean: removes the build directory
  install  : installs the targets on the system
  list     : lists the targets to execute
  step     : executes tasks in a step-by-step fashion, for debugging
  uninstall: removes the targets installed

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -j JOBS, --jobs=JOBS  amount of parallel jobs (2)
  -k, --keep            keep running happily on independent task groups
  -v, --verbose         verbosity level -v -vv or -vvv [default: 0]
  --nocache             ignore the WAFCACHE (if set)
  --zones=ZONES         debugging zones (task_gen, deps, tasks, etc)

  configure options:
    -o OUT, --out=OUT   build dir for the project
    -t TOP, --top=TOP   src dir for the project
    --prefix=PREFIX     installation prefix [default: '/usr/local/']
    --download          try to download the tools if missing

  build and install options:
    -p, --progress      -p: progress bar; -pp: ide output
    --targets=TARGETS   task generators, e.g. "target1,target2"

  step options:
    --files=FILES       files to process, by regexp, e.g. "*/main.c,*/test/main.o"

  install/uninstall options:
    --destdir=DESTDIR   installation root [default: '']
    -f, --force         force file installation
---------------

Accessing a command-line option is possible from any command. Here is how to access the value 'prefix':

[source,python]
---------------
top = '.'
out = 'build_directory'

def configure(ctx):

	from waflib import Options
	print('→ prefix is ' + Options.options.prefix)
---------------

Upon execution, the following will be observed:

[source,shishell]
---------------
$ waf configure
→ prefix is /usr/local/
'configure' finished successfully (0.001s)
---------------

To define project command-line options, a special command named 'options' may be defined in user scripts. This command will be called once before any other command executes.

[source,python]
---------------
top = '.'
out = 'build_directory'

def options(ctx):
	ctx.add_option('--foo', action='store', default=False, help='Silly test')

def configure(ctx):

	from waflib import Options
	print('→ the value of foo is %r' % Options.options.foo)
---------------

Upon execution, the following will be observed:

[source,shishell]
---------------
$ waf configure --foo=test
→ the value of foo is 'test'
'configure' finished successfully (0.001s)
---------------

The command context for options is a shortcut to access the optparse functionality. For more information on the optparse module, consult the http://docs.python.org/library/optparse.html[Python documentation]

