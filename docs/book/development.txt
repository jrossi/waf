== Using the development version

A few notes on the waf development follow.

=== Tracing the execution

The generic flags to add more information to the stack traces or to the messages is '-v' (verbosity), it is used to display the command-lines executed during a build:

[source,shishell]
---------------
$ waf -v
---------------

To display all the traces (useful for bug reports), use the following flag:

[source,shishell]
---------------
$ waf -vvv
---------------

Debugging information can be filtered easily with the flag 'zones':

[source,shishell]
---------------
$ waf --zones=action
---------------

Tracing zones must be comma-separated, for example:

[source,shishell]
---------------
$ waf --zones=action,envhash,task_gen
---------------

The Waf module 'Logs' replaces the Python module logging. In the source code, traces are provided by using the 'debug' function, they must obey the format "zone: message" like in the following:

[source,python]
---------------
Logs.debug("task: task %r must run as it was never run before or the task code changed" % self)
---------------

The following zones are used in Waf:

.Debugging zones
[options="header",cols='1,5']
|=================
|Zone    | Description
|runner  | command-lines executed (enabled when -v is provided without debugging zones)
|deps    | implicit dependencies found (task scanners)
|task_gen| task creation (from task generators) and task generator method execution
|action  | functions to execute for building the targets
|env     | environment contents
|envhash | hashes of the environment objects - helps seeing what changes
|build   | build context operations such as filesystem access
|preproc | preprocessor execution
|group   | groups and task generators
|=================

WARNING: Debugging information can be displayed only after the command-line has been parsed. For example, no debugging information will be displayed when a waf tool is being by 'tool_options'

=== Benchmarking

The script `utils/genbench.py` generates a simple benchmark for Waf. The habitual use is the following:

[source,shishell]
---------------
$ utils/genbench.py /tmp/build 50 100 15 5
$ cd /tmp/build
$ waf configure
$ waf -p -j2
---------------

The project created contains 50 libraries with 100 classes for each, each source file having 15 include headers pointing to the same library and 5 headers pointing to the headers of other libraries in the project.

The time taken to create the tasks and to resolve the dependencies can be obtained by injecting code to disable the actual compilation, for example:

[source,python]
---------------
def build(bld):
	from waflib import Task
	def touch_func(task):
		for x in task.outputs:
			x.write('')
	for x in Task.TaskBase.classes.keys():
		cls = Task.TaskBase.classes[x]
		cls.func = touch_func
		cls.color = 'CYAN'
---------------

=== Profiling

Profiling information is obtained by calling the module cProfile and by injecting specific code. The most interesting methods to profile is 'waflib.Build.BuildContext.compile'. The amount of function calls is usually a bottleneck, and reducing it results in noticeable speedups. Here is an example on the method compile:

[source,python]
---------------
from waflib.Build import BuildContext
def ncomp(self):
	import cProfile, pstats
	cProfile.runctx('self.orig_compile()', {}, {'self': self}, 'profi.txt')
	p = pstats.Stats('profi.txt')
	p.sort_stats('time').print_stats(45)

BuildContext.orig_compile = BuildContext.compile
BuildContext.compile = ncomp
---------------

Here the output obtained on a benchmark build created as explained in the previous section:

[source,shishell]
---------------
Fri Jul 23 15:11:15 2010    profi.txt

         1114979 function calls (1099879 primitive calls) in 5.768 CPU seconds

   Ordered by: internal time
   List reduced from 139 to 45 due to restriction 45

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   109500    0.523    0.000    1.775    0.000 /comp/waf/waflib/Node.py:615(get_bld_sig)
     5000    0.381    0.000    1.631    0.000 /comp/waf/waflib/Task.py:475(compute_sig_implicit_deps)
   154550    0.286    0.000    0.286    0.000 {method 'update' of '_hashlib.HASH' objects}
   265350    0.232    0.000    0.232    0.000 {id}
40201/25101    0.228    0.000    0.228    0.000 /comp/waf/waflib/Node.py:319(abspath)
    10000    0.223    0.000    0.223    0.000 {open}
    20000    0.197    0.000    0.197    0.000 {method 'read' of 'file' objects}
    15000    0.193    0.000    0.349    0.000 /comp/waf/waflib/Task.py:270(uid)
    10000    0.189    0.000    0.850    0.000 /comp/waf/waflib/Utils.py:96(h_file)
---------------

A few known hot spots are present in the library:

. The persistence implemented by the cPickle module (the cache file to serialize may take a few megabytes)
. Accessing configuration data from the Environment instances
. Computing implicit dependencies in general

=== Tracing parallel task execution

The Waf tool named _ParallelDebug_ is used to inject code in Waf modules and to obtain a detailed execution trace. This module is provided in the folder _extras_ and must be imported in one's project before use:

[source,python]
---------------
def configure(conf):
	conf.check_tool('ParallelDebug', tooldir='.')
---------------

After executing a full build, the file +test.dat+ may be processed by other applications such as Gnuplot:

[source,shishell]
---------------
set terminal png
set output "output.png"
set ylabel "Amount of jobs running in parallel"
set xlabel "Time in seconds"
set title "Amount of jobs running in parallel (waf -j5)"
unset label
set yrange [-0.1:5.2]
set ytic 1
plot 'test.dat' using 1:3 with lines title "" lt 2
---------------

image::dev{PIC}["Tracing the threads being executed"{backend@docbook:,width=410:},align="center"]

=== Optimization guidlines

The Waf source code has already been optimized in various ways. In practice, the projects may use additional assumptions to replace certain methods or parameters from its build scripts. For example, if a project is always executed on Windows, then the _framework_ and _rpath_ variables may be removed:

[source,python]
---------------
from waflib.Tools.ccroot import USELIB_VARS
USELIB_VARS['cprogram'] = USELIB_VARS['cxxprogram'] = \
	set(['LIB', 'STLIB', 'LIBPATH', 'STLIBPATH', 'LINKFLAGS', 'LINKDEPS'])
---------------

=== Hacking on the source code

Waf is hosted on http://code.google.com/p/waf/source[Google code], and uses Subversion for source control. To obtain the development copy, use:

[source,shishell]
---------------
$ svn checkout http://waf.googlecode.com/svn/trunk/ waf-read-only
$ cd waf-read-only
$ ./waf-light --make-waf
---------------

To avoid regenerating Waf each time, the environment variable *WAFDIR* should be used to point at the directory containing _waflib_:

[source,shishell]
---------------
$ export WAFDIR=/path/to/directory/
---------------

=== Programming guidelines

Though Waf is written in Python, additional restrictions apply to the source code:

. Identation is tab-only, and the maximum line length should be about 200 characters
. The development code is kept compatible with Python 2.3, to the exception of decorators in the Tools directory. In particular, the Waf binary can be generated using Python 2.3
. The _waflib_ modules must be insulated from the _Tools_ modules to keep the Waf core small and language independent
. Api compatibility is maintained in the cycle of a minor version (from 1.5.0 to 1.5.n)

NOTE: More code always means more bugs. Whenever possible, unnecessary code must be removed, and the existing code base should be simplified.

