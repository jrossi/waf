== The configuration system

The _configuration_ command is used to check if the requiremements for working on a project are met and to store the information. The parameters are then stored for use by other commands, such as the build command.

=== Using persistent data

==== Sharing data with the build

The configuration context is used to store data which may be re-used during the build. Let's begin with the following example:

// configuration_build
[source,python]
---------------
top = '.'
out = 'build'

def options(ctx):
	ctx.add_option('--foo', action='store', default=False, help='Silly test')

def configure(ctx):
	ctx.env.FOO = ctx.options.foo <1>
	ctx.find_program('touch', var='TOUCH') <2>

def build(ctx):
	print(ctx.env.FOO) <3>
	print(ctx.env.TOUCH)
	bld(rule='${TOUCH} ${TGT}', target='foo.txt') <4>
---------------

<1> Store the option _foo_ into the variable _env_ (dict-like structure)
<2> Configuration routine used to find the program _touch_ and to store it into _ctx.env.TOUCH_
<3> Print the value of _ctx.env.FOO_ that was set during the configuration
<4> The variable _$\{TOUCH}_ corresponds to the variable _env.TOUCH_

[source,shishell]
---------------
$ waf distclean configure build --foo=abcd -v
'distclean' finished successfully (0.005s)
Checking for program touch               : /usr/bin/touch <1>
'configure' finished successfully (0.007s)
Waf: Entering directory `/disk/comp/waf/docs/book/examples/configuration_build/build'
/usr/bin/touch <2>
abcd
[1/1] bar.txt:  -> build/bar.txt
10:56:41 runner '/usr/bin/touch bar.txt' <3>
Waf: Leaving directory `/disk/comp/waf/docs/book/examples/configuration_build/build'
'build' finished successfully (0.021s)
---------------
<1> Output of the configuration test _find_program_
<2> The value of _TOUCH_
<3> Command-line used to create the target 'bar.txt'

The variable _ctx.env_ is called a *Configuration set*, and is an instance of the class 'ConfigSet'. The class is a wrapper around Python dicts to handle serialization. For this reason it should be used for simple variables only (no functions or classes). The values are stored in a python-like format in the build directory:

[source,shishell]
---------------
$ tree
build/
|-- bar.txt
|-- c4che
|   |-- build.config.py
|   `-- default.cache.py
`-- config.log

$ cat build/c4che/default.cache.py
FOO = 'abcd'
PREFIX = '/usr/local'
TOUCH = '/usr/bin/touch'
---------------

NOTE: Reading and writing values to _ctx.env_ is possible in both configuration and build commands. Yet, the values are stored to a file only during the configuration phase.

==== Configuration set usage

We will now provide more examples of the configuration set usage. The object *conf.env* provides convenience methods to access its contents:

// configuration_sets
[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	ctx.env['CCFLAGS'] = ['-g'] <1>
	ctx.env.CCFLAGS = ['-g'] <2>
	ctx.env.append_value('CXXFLAGS', ['-O2', '-g']) <3>
	ctx.env.append_unique('CCFLAGS', ['-g', '-O2'])
	ctx.env.prepend_value('CCFLAGS', ['-O3']) <4>

	print(type(ctx.env))
	print(ctx.env)
	print(env.FOO)
----------------

<1> Key-based access; storing a list
<2> Attribute-based access (the two forms are equivalent)
<3> Append a each element value to the list _ctx.env.CXXFLAGS_, assuming it is a list
<4> Insert the values at the beginning. Note that there is no such method as _prepend_unique_

The execution will produce the following output:

[source,shishell]
---------------
$ waf configure
<class 'waflib.ConfigSet.ConfigSet'> <1>
'CCFLAGS' ['-O3', '-g', '-O2'] <2>
'CXXFLAGS' ['-O2', '-g']
'PREFIX' '/usr/local'
[] <3>

$ cat build/c4che/default.cache.py <4>
CCFLAGS = ['-O3', '-g', '-O2']
CXXFLAGS = ['-O2', '-g']
PREFIX = '/usr/local'
---------------

<1> The object _conf.env_ is an instance of the class ConfigSet defined in _waflib/ConfigSet.py_
<2> The contents of _conf.env_ after the modifications
<3> When a key is undefined, it is assumed that it is a list (used by *append_value* above)
<4> The object _conf.env_ is stored by default in this file

Copy and serialization apis are also provided:

// configuration_copysets
[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	ctx.env.FOO = 'TEST'

	env_copy = ctx.env.derive() <1>

	node = ctx.path.make_node('test.txt') <2>
	env_copy.store(node.abspath()) <3>

	from waflib.ConfigSet import ConfigSet
	env2 = ConfigSet() <4>
	env2.load(node.abspath()) <5>

	print(node.read())
---------------

<1> Make a copy of _ctx.env_ - this is a shallow copy
<2> Use *ctx.path* to create a node object representing the file +test.txt+
<3> Store the contents of *env_copy* into +test.txt+
<4> Create a new empty ConfigSet object
<5> Load the values from +test.txt+
<6> Print the contents of +test.txt+

Upon execution, the output will be the following:

[source,shishell]
---------------
$ waf distclean configure
'distclean' finished successfully (0.005s)
FOO = 'TEST'
PREFIX = '/usr/local'
'configure' finished successfully (0.006s)
---------------

// ===== multiple configuration sets?

=== Configuration utilities

==== Configuration methods

The method _ctx.find_program_ seen previously is an example of a configuration method. Here are more examples:

// configuration_methods
[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	ctx.find_program('touch', var='TOUCH')
	ctx.check_waf_version(mini='1.6.0')
	ctx.find_file('fstab', ['/opt', '/etc'])
---------------

Although these methods are documented in http://freehackers.org/~tnagy/wafdoc160/[the apidocs], they do not belong to the class of the context object (_waflib.Configure.ConfigurationContext_). Rather, the methods are defined as simple functions outside of any class:

[source,python]
---------------
top = '.'
out = 'build'

from waflib.Configure import conf <1>

@conf <2>
def hi(ctx):
	print('→ hello, world!')

# hi = conf(hi) <3>

def configure(ctx):
	ctx.hi() <4>
---------------

<1> Import the decorator *conf*
<2> Use the decorator to bind the method _hi_ to the configuration context class
<3> Decorators are simple python function. Python 2.3 does not support the *@* syntax so the function has to be called after the function declaration
<4> Use the method previously bound to the configuration context class

The execution will produce the following output:

[source,shishell]
---------------
$ waf configure
→ hello, world!
'configure' finished successfully (0.005s)
---------------

==== Loading and using Waf tools

For efficiency reasons, the Waf core libraries do not provide support for programming languages. The configuration helpers are located in separate files called 'Waf tools' and located under the folder +waflib/Tools+. The contributed tools, or the tools in testing phase are located under the folder +waflib/extras+.

Tools usually provide additional routines, and may modify existing classes to extend their behaviour. We will now demonstrate a very simple Waf tool named `dang.py`:

[source,python]
---------------
from Configure import conf <1>

def configure(conf): <2>
	print('→ configure from dang!')

@conf
def test_hello(conf):
	print('→ test from dang!')

@conf
def build_hello(self):
	print('→ build hello from dang!')
---------------

<1> The decorator 'conf' is used to bind functions as new methods to the 'configuration context class'
<2> The default detection method to execute when the tool is loaded is called 'configure'

For loading a tool, the method 'check_tool' must be used during the configuration. The same tools are then loaded during the build.:

[source,python]
---------------
top = '.'
out = 'build'

#from waflib import c_config <1>

def configure(conf):

	#from waflib import c_config <2>

	def is_check_cc_present():
		try:
			print('→ method conf.check_cc %r' % conf.check_cc) <3>
		except:
			print('→ there is no method conf.check_cc')

	is_check_cc_present()
	conf.check_tool('config_c') <4>
	is_check_cc_present()

	conf.check_tool('dang', tooldir='.') <5>
	conf.check_tool('dang', tooldir='.', funs='test_hello') <6>
	conf.check_tool('dang', tooldir='.') <7>

def build(bld):
	bld.build_hello() <8>
---------------

<1> By loading a Waf tool at the root of a script, the detection routines will not be executed (discouraged)
<2> By loading a Waf tool using _import_, the tool will not be loaded at build time (discouraged)
<3> Just an example to show if the method _check_cc_ is present on the configuration context class
<4> Load the tool providing configuration routines for c and c++ support (the method check_cc)
<5> If a method named _configure_ is provided, it will be executed during _conf.check_tool_
<6> Use specific functions instead of calling the default
<7> To ease the creation of projects split into modules, conf.check_tool will not load the tools twice for the same environment and the same parameters.
<8> The configuration context methods are also bound to the build context

Upon execution, the output will be the following:

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.002s)
→ there is no method conf.check_cc
→ method conf.check_cc (ConfigurationContext.check_cc)
→ configure from dang!
→ test from dang!
'configure' finished successfully (0.003s)
Waf: Entering directory `/tmp/smallproject/build'
→ build hello from dang!
Waf: Leaving directory `/tmp/smallproject/build'
'build' finished successfully (0.003s)
---------------


=== Exception handling

==== Launching and catching configuration exceptions

Configuration helpers are methods provided by the conf object to help finding parameters, for example the method 'conf.find_program'

[source,python]
---------------
def configure(conf):
	conf.find_program('test')
---------------

When a test fails, the exception 'waflib.Errors.ConfigurationError' is raised. For example, such exceptions are thrown when a program could not be found:

[source,python]
---------------
def configure(conf):
	from waflib.Errors import ConfigurationError
	try:
		conf.find_program('missing_app', mandatory=True)
	except ConfigurationError:
		pass
	conf.find_program(['gjc', 'cjg'], mandatory=True)
---------------

The output will be:

[source,shishell]
---------------
$ waf
Checking for program missing_app         : not found
Checking for program gjc,cjg             : not found
 error: The program ['gjc', 'cjg'] could not be found
---------------

It is sometimes useful to raise such an exception manually by using 'conf.fatal':

[source,python]
---------------
def configure(conf):
	conf.fatal("I'm sorry Dave, I'm afraid I can't do that")
---------------

Which will display the same kind of error

[source,shishell]
---------------
$ waf configure
 error: I'm sorry Dave, I'm afraid I can't do that
$ echo $?
1
---------------


==== Handling configuration exceptions

An error handler attached to the conf object is used for catching the Configuration exceptions and processing the errors. Here is how to replace the default configuration error handler by a custom method which may modify the list of tests, stop the evaluation, or re-raise the exception:

[source,python]
---------------
from waflib.Configure import conf, BREAK, CONTINUE

@conf
def error_handler(fun, exc):
	print('exception %r' % exc)
	# other optionals return values: CONTINUE or anything else to re-raise the exception
	return BREAK
---------------

The following diagram illustrates the test execution loop performed from conf.check_tool

image::conftest{PIC}["Configuration tests"{backend@docbook:,width=250:}]

