== Advanced build definitions

=== Custom commands

==== Commands inheritance

The context for a command is created automatically, and is derived from the class 'Utils.Context'. Custom context instance may be provided in the following manner:

[source,python]
---------------
def configure(ctx):
	pass

def foo(ctx):
	pass

from waflib.Context import Context
class context(Context):
	fun = 'foo'
	def __init__(self):
		print("a context for 'foo'")
---------------

Custom contexts may be provided for the functions 'configure' and 'build'.


commands inherit waflib.Context and so subclasses can be mades
  . fun
  . cmd
typical is to inherit waflib.Build.BuildContext to obtain the configuration data (ctx.env)
  provide an example

==== Scripting.commands manipulation

When several commands with incompatible contexts must be executed in a row, they may be injected in the following manner:

[source,python]
---------------
from waflib import Scripting
def foo(ctx):
	Scripting.commands += ['build', 'clean']
---------------

Injecting new commands is useful for writing testcases. By executing 'waf test', the following script will configure a project, create source files in the source directory, build a program, modify the sources, and rebuild the program. In this case, the program must be rebuilt because a header (implicit dependency) has changed.

[source,python]
---------------
VERSION = '0.0.1'
APPNAME = 'my_testcase'

top = '.'
out = 'build'

from waflib import Scripting

def test(ctx):
	lst = 'distclean configure setup build modify build'.split()
	Scripting.commands += lst

def configure(conf):
	conf.check_tool('gcc')

def setup(ctx):
	n = ctx.path.make_node('main.c')
	n.write('#include "foo.h"\nint main() {return 0;}\n')

	m = ctx.path.make_node('foo.h')
	m.write('int k = 32;\n')

def build(bld):
	bld.program(
		source   = 'main.c',
		target   = 'tprog')

def modify(ctx):
	m = ctx.path.make_node('foo.h')
	m.write('int k = 34;\n')
---------------

In the following scenario, the build files are installed into a temporary directory for packaging. This is different from the `waf dist` command which only packages the source files needed for the project.

Because the context objects usually derive from different classes, it is usually forbidden to call a command from another commands. In the following example, the commands to execute are pushed onto a stack:

[source,python]
---------------
top = '.'
out = 'out'

from waflib import Scripting

def configure(conf):
	conf.check_tool('gcc')

def build(bld):
	bld.install_files('/tmp/foo/', 'wscript') <1>
	bld(features='cc cprogram', target='foo', source='k.c')

back = False
def package(ctx): <2>
	global back
	Scripting.commands.insert(0, 'package') <3>
	Scripting.commands.insert(0, 'install') <4>
	back = ctx.options.destdir <5>
	ctx.options.destdir = '/tmp/foo'

def create_package(ctx): <6>
	global back
	print("packaging")
	ctx.options.destdir = back <7>
---------------

<1> Perform the installation
<2> Users will call 'waf package' to create the package
<3> Postpone the actual package creation
<4> Now the next command to execute is the installation, and after the installation, the package creation will be performed
<5> Change the value of 'destdir' for installing the files into a temporary directory
<6> Command for creating the package
<7> Restore the value of 'destdir', in case if more commands are to be executed

Note that the 'destdir' parameter is being passed between commands by means of a global option.


==== Adding a command from a waf tool

When the top-level wscript is read, it is converted into a python module and kept in memory. To add a new command dynamically,
it is only necessary to inject the desired function into that module. We will now show how to load a waf tool to count the amount of task generators
in the project.

The waf tools are loaded once during the configuration and during the build. To ensure that the tool is always loaded, it is necessary to load its options:

[source,python]
---------------
top = '.'
out = 'build'

def options(opt):
	opt.tool_options('some_tool', tooldir='.')

def configure(conf):
	pass

def build(bld):
	bld(rule='echo "hi"', always=True, name='a')
	bld(rule='echo "there"', always=True, name='b')
---------------

Now our tool 'some_tool.py', located next to the 'wscript' file, will contain the following code:

[source,python]
---------------
import os
from waflib import Utils, ConfigSet, Options, Build

def options(opt): <1>
	pass

def list_targets(ctx): <2>
	"""return the amount of targets"""

	bld = Build.BuildContext() <3>
	proj = ConfigSet.ConfigSet(Options.lockfile) <4>
	bld.load_dirs(proj['top'], proj['out']) <5>
	bld.load_envs()

	bld.add_subdirs([os.path.split(Utils.g_module.root_path)[0]]) <6>

	names = set([])
	for x in bld.all_task_gen: <7>
		try:
			names.add(x.name or x.target)
		except AttributeError:
			pass

	lst = list(names)
	lst.sort()
	for name in lst:
		print(name)
Utils.g_module.__dict__['list_targets'] = list_targets <8>
---------------

<1> The function 'options' is called by 'tool_options' above
<2> The command that will be injected dynamically from this tool
<3> Declare a build context manually
<4> Read the project settings
<5> Initialize the build context
<6> Read the project files, executing the methods 'build'
<7> Access the declared task generators stored in the build context attribute 'all_task_gen'
<8> Bind the function as a new command

The execution output will be the following.

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/home/waf/tmp/nt/build'
[1/2] echo "hi":
hi
[2/2] echo "there":
there
Waf: Leaving directory `/home/waf/tmp/nt/build'
'build' finished successfully (0.015s)

$ waf list_targets
a
b
'list_targets' finished successfully (0.003s)

$ waf --targets=a
Waf: Entering directory `/home/waf/tmp/nt/build'
[1/1] a:
hi
Waf: Leaving directory `/home/waf/tmp/nt/build'
'build' finished successfully (0.012s)
---------------

Note that during the execution of `num_targets`, the task generator definitions have been read but no task was executed.

=== Custom build outputs

==== Multiple configurations

example with a separate build directory

example with the lock file

It is not possible to use several Waf instances concurrently over the same build folder. Yet, several Waf instances may use the project at the same time. For this, two options must be set:

. The environment variable `WAFCACHE`
. The build directory, using a command-line option

Here is an example for a simple project located in '/tmp/smallfolder'`:

[source,python]
---------------
top = '.'
out = 'out_directory'

def configure(conf):
	pass

def build(bld):
	bld(rule='touch ${TGT}', target='foo.txt')
---------------

Upon execution, the results will be the following:

[source,shishell]
---------------
$ export WAFLOCK=.lock-debug <1>

$ waf distclean configure -b debug <2>
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.001s)

$ waf
Waf: Entering directory `/tmp/smallproject/debug'
[1/1] foo.txt:  -> debug/default/foo.txt <3>
Waf: Leaving directory `/tmp/smallproject/debug'
'build' finished successfully (0.012s)

$ export WAFLOCK=.lock-release

$ waf distclean configure -b release
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.176s)

$ waf
Waf: Entering directory `/tmp/smallproject/release' <4>
[1/1] foo.txt:  -> release/default/foo.txt
Waf: Leaving directory `/tmp/smallproject/release'
'build' finished successfully (0.034s)

$ tree -a
.
|-- .lock-debug <5>
|-- .lock-release
|-- debug
|   |-- .wafpickle-7
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- foo.txt
|-- release
|   |-- .wafpickle-7
|   |-- c4che
|   |   |-- build.config.py
|   |   `-- default.cache.py
|   |-- config.log
|   `-- foo.txt
`-- wscript
---------------

<1> The environment variable 'WAFLOCK' points at the configuration of the project in use.
<2> The lockfile is created during the configuration.
<3> The files are output in the build directory `debug`
<4> The configuration 'release' is used with a different lock file and a different build directory.
<5> The contents of the project directory contain the two lock files and the two build folders.

When waf is executed, it reads the variable 'WAFLOCK' on an internal variable, which may be modified programmatically:

[source,python]
---------------
from waflib import Options
Options.lockfile = '.lockfilename'
---------------

==== Build output directory (bld.variant)

example


