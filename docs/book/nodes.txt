== Waf nodes

Node objects represent files or folders and are used to ease the operations dealing with the file system. This chapter provides an overview of their usage.

=== Design of the node class

==== The node tree

The Waf nodes inherit the class _waflib.Node.Node_ and provide a tree structure to represent the file system:

. *parent*: parent node
. *children*: folder contents - or empty if the node is a file

In practice, the reference to the filesystem tree is bound to the context classes for access from Waf commands. Here is an illustration:

// nodes_tree
[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
    pass

def dosomething(ctx):
    print(ctx.path.abspath()) <1>
    print(ctx.root.abspath()) <2>
    print("ctx.path contents %r" % ctx.path.children)
    print("ctx.path parent   %r" % ctx.path.parent.abspath())
    print("ctx.root parent   %r" % ctx.root.parent)
---------------

<1> *ctx.path* represents the path to the +wscript+ file being executed
<2> *ctx.root* is the root of the file system or the folder containing the drive letters (win32 systems)

The execution output will be the following:

[source,shishell]
---------------
$ waf configure dosomething
Setting top to    : /tmp/node_tree
Setting out to    : /tmp/node_tree/build
'configure' finished successfully (0.007s)
/tmp/node_tree <1>
/
ctx.path contents {'wscript': /tmp/node_tree/wscript} <2>
ctx.path parent   '/tmp' <3>
ctx.root parent   None <4>
'dosomething' finished successfully (0.001s)
---------------

<1> Absolute paths are used frequently
<2> The folder contents are stored in the dict _children_ which maps names to node objects
<3> Each node keeps reference to his _parent_ node
<4> The root node has no _parent_

NOTE: There is a strict correspondance between nodes and filesystem elements: a node represents exactly one file or one folder, and only one node can represent a file or a folder.

==== Node caching

By default, only the necessary nodes are created:

// nodes_cache
[source,python]
---------------
def configure(ctx):
    pass

def dosomething(ctx):
    print(ctx.root.children)
---------------

The filesystem root appears to only contain one node, although the real filesystem root contains more folders than just +/tmp+:

[source,shishell]
---------------
$ waf configure dosomething
Setting top to   : /tmp/nodes_cache
Setting out to   : /tmp/nodes_cache/build
'configure' finished successfully (0.086s)
{'tmp': /tmp}
'dosomething' finished successfully (0.001s)

$ ls /
bin boot dev etc home tmp usr var
---------------

This means in particular that some nodes may have to be read from the file system or created before being used.

// ==== nodes and signatures TODO


=== General usage

==== Searching and creating nodes

Nodes may be created manually or read from the file system. Three methods are provided for this purpose:

// nodes_search
[source,python]
---------------
def configure(ctx):
	pass

def dosomething(ctx):
	print(ctx.path.find_node('wscript')) <1>

	nd1 = ctx.path.make_node('foo.txt') <2>
	print(nd1)

	nd2 = ctx.path.search('foo.txt') <3>
	print(nd2)

	nd3 = ctx.path.search('bar.txt') <4>
	print(nd3)

	nd2.write('some text') <5>
	print(nd2.read())

	print(ctx.path.listdir())
---------------

<1> Search for a nodes by reading the file system
<2> Search for a node or create it if it does not exist
<3> Search for a node but do not try to create it
<4> Search for a file which does not exist
<5> Write to the file pointed by the node, creating or overwriting the file

The output will be the following:

[source,shishell]
---------------
$ waf distclean configure dosomething
'distclean' finished successfully (0.005s)
Setting top to    : /tmp/nodes_search
Setting out to    : /tmp/nodes_search/build
'configure' finished successfully (0.006s)
wscript
foo.txt
foo.txt
None
some text
['.lock-wafbuild', 'foo.txt', 'build', 'wscript', '.svn']
---------------

NOTE: More methods may be found in the http://freehackers.org/~tnagy/wafdoc160/[API documentation]

WARNING: These methods are not safe for concurrent access. The node class methods are not thread-safe.

==== Finding files recursively

Files and folders may be found recursively by using the method *ant_glob*:

// nodes_ant_glob
[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	pass

def dosomething(ctx):
	print(ctx.path.ant_glob('wsc*'))<1>
	print(ctx.path.ant_glob('w?cr?p?'))<2>
	print(ctx.root.ant_glob('usr/include/**/zlib*' <3>, dir=False, src=True))
---------------

<1> The method ant_glob is called on a node object, and not on the build context
<2> The patterns may contain wildcards such as * or ?, but they are http://ant.apache.org/manual/dirtasks.html[Ant patterns], not regular expressions
<3> The '**' indicates to consider folders recursively. Use with care.

The execution output will be similar to the following:

[source,shishell]
---------------
$ waf configure dosomething
Setting top to    : /tmp/nodes_ant_glob
Setting out to    : /tmp/nodes_ant_glob/build
'configure' finished successfully (0.006s)
[/tmp/nodes_ant_glob/wscript]
[/tmp/nodes_ant_glob/wscript]
[/usr/include/boost/iostreams/detail/config/zlib.hpp,
  /usr/include/boost/iostreams/filter/zlib.hpp, /usr/include/zlib.h]
---------------

==== path manipulation: abspath, path_from

The method 'abspath' is used to obtain the absolute path for a node. In the following example, three nodes are used:

[source,python]
---------------
top = '.'
out = 'build'

def configure(conf):
	pass

def build(ctx):
	dir = ctx.path <1>
	src = ctx.path.find_resource('wscript')
	bld = ctx.path.find_or_declare('out.out')

	print(src.abspath(ctx.env)) <2>
	print(bld.abspath(ctx.env))
	print(dir.abspath(ctx.env)) <3>
	print(dir.abspath())
---------------

<1> Directory node, source node and build node
<2> Computing the absolute path for source node or a build node takes a configuration set as parameter
<3> Computing the absolute path for a directory may use a configuration set or not

Here is the execution trace:

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.005s)
Waf: Entering directory `/tmp/nested/build'
/tmp/nested/wscript <1>
/tmp/nested/build/default/out.out <2>
/tmp/nested/build/default/ <3>
/tmp/nested <4>
Waf: Leaving directory `/tmp/nested/build'
'build' finished successfully (0.003s)
---------------

<1> Absolute path for the source node
<2> The absolute path for the build node depends on the variant in use
<3> When a configuration set is provided, the absolute path for a directory node is the build directory representation including the variant
<4> When no configuration set is provided, the directory node absolute path is the one for the source directory

NOTE: Several other methods such as 'relpath_gen' or 'srcpath' are provided. See the http://freehackers.org/~tnagy/wafdoc/index.html[api documentation]

=== BuildContext-specific methods

==== specific use in the configuration/build

describe why ...

==== srcnode/bldnode , get_src/get_bld

TODO

==== Using Nodes during the build phase

Three main Node methods are commonly used for accessing the file system during the build. They accept a string representing the target as input and return a single node:

. *find_dir*: returns a node or None if the folder cannot be found on the system.
. *find_resource*: returns a node under the source directory, a node under the corresponding build directory, or None if no such a node exists. If the file is not in the build directory, the node signature is computed and put into a cache (file contents hash).
. *find_or_declare*: returns a node or create the corresponding node in the build directory.

All these methods will create the required directory structure in the build directory my calling _find_dir_ internally. Because the folders may be replicated in the build directory before the build starts, it is recommended to use it whenever possible:

[source,python]
---------------
def build(bld):
	p = bld.path.parent.find_dir('src') <1>
	p = bld.path.find_dir('../src') <2>
---------------

<1> Not recommended, use _find_dir_ instead
<2> Path separators are converted automatically according to the platform.


// hmmm clean the stuff below ///////////////////////////////////////////////////////////////////////////////////////

=== Build context creation and access

For testing purposes, a function created from a build context instance could create another build context. Therefore, the build context is not a singleton. The task signatures and the dependent nodes are then bound to the build context instance that created them.

Here is how to create a build context inside another build context:

[source,python]
---------------
top = '.'
out = 'build'

def configure(conf):
	pass

def build(ctx):

	def do_it():

		from waflib import ConfigSet, Build
		bld = Build.BuildContext() <1>
		bld.load_dirs('/tmp', '/tmp/build') <2>
		env = ConfigSet.ConfigSet()
		bld.all_envs['default'] = env <3>
		bld.init_variants() <4>

		bld( <5>
			rule   = 'echo hi from the nested context!',
			always = True)

		bld.compile() <6>

	ctx( <7>
		rule   = 'echo hi from the main buildcontext',
		always = True)

	do_it() <8>
---------------

<1> Create a new build context.
<2> Set the project and the output folders
<3> Set the configuration data set
<4> Create the folder(s) '/tmp/build/variant' and initialize the build node signature cache
<5> Declare a task generator
<6> Execute a build
<7> Create a task generator for the main build context
<8> Call the function 'do_it' to create immediately a new build context and to execute it

The execution trace is the following:

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.002s)
Waf: Entering directory `/tmp/nested/build'
[1/1] echo hi from the nested context!: <1>
hi from the nested context!
[1/1] echo hi from the main buildcontext:
hi from the main buildcontext <2>
Waf: Leaving directory `/tmp/nested/build'
'build' finished successfully (0.018s)
---------------

<1> The nested build is executed immediately
<2> Trace from the normal build

The task generators, the tasks, and the node objects are all bound to a particular build context. Here is how to access the different objects:

[source,python]
---------------
top = '.'
out = 'build'

def configure(conf):
    pass

def build(bld):
    print('root %r' % type(bld.root)) <1>
    print('path %r' % bld.path) <2>
    print('path %r' % bld.srcnode) <3>
    print('bld %r' % bld.path.__class__.bld) <4>

    def fun(task):
        print("task %r %r -> %r" % (
            type(task),
            task.generator, <5>
            task.generator.bld) <6>
        )

    obj = bld(rule=fun, always=True, name='foo')
    print('tgen %r -> %r' % (type(obj), obj.bld)) <7>
    print(bld.name_to_obj('foo', bld.env)) <8>
---------------

<1> Filesystem root
<2> Current path
<3> Project directory (top-level)
<4> Access the build context instance from the class
<5> Get a reference to the task generator that created the task instance
<6> Get the build context corresponding to the task instance
<7> The attribute 'bld' of a task generator is the build context
<8> Obtain a task generator from the build context

The execution trace will be the following:

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.001s)
'configure' finished successfully (0.002s)
Waf: Entering directory `/tmp/nested/build'
root <class 'Node.Nodu'>
path dir:///tmp/nested
src  dir:///tmp/nested
bld <Build.BuildContext object at 0x7f5472764490>
tgen <class 'TaskGen.task_gen'> -> <Build.BuildContext object at 0x7f5472764490>
<task_gen 'foo' of type task_gen defined in dir:///tmp/nested>
[1/1] 1:
task <class 'Task.1'> <TaskGen.task_gen object at 0x7f547277b610>
     -> <Build.BuildContext object at 0x7f5472764490>
Waf: Leaving directory `/tmp/nested/build'
'build' finished successfully (0.007s)
---------------

NOTE: Tasks created by task generators are somehow private objects. They should not be manipulated directly in the 'build' function, but rather by task generator methods.

