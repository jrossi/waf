== The build phase

We will now provide a detailed description of the build phase, which is used for processing the build targets.

=== Diving into the _build_ command

==== Analysis of a simple build

To illustrate the various concepts that are part of the build process, we are now going to use a new example.
The files +foo.txt+ and +bar.txt+ will be created by copying the file +wscript+, and the file +foobar.txt+ will be created from the concatenation of the generated files. Here is a possible representation displaying the command to use, the input files, and the output files:

[source,shishell]
---------------
cp: wscript -> foo.txt
cp: wscript -> bar.txt
cat: foo.txt, bar.txt -> foobar.txt
--------------

The three lines represent the *tasks* to execute. While the _cp_ tasks may be executed in any order or even in parallel, the _cat_ task may only be executed after all the _cp_ tasks are done. This represents a constraint on *the build order*. The arrows represent *dependencies*: when the +wscript+ file changes, the +foo.txt+ file must be generated again.

The dependencies are represented on the following graph:

image::manualtasks{PIC}["Dependencies on a simple build"{backend@docbook:,width=120:}]

Note that the structure represented is a http://en.wikipedia.org/wiki/Directed_acyclic_graph[Directed acyclic graph]

==== Direct task declaration

We will now represent the build from the previous section by declaring the tasks directly in the build section:

[source,python]
---------------
def configure(ctx):
	pass

from waflib.Task import Task
class cp(Task): <1>
	def run(self): <2>
		return self.exec_command('cp %s %s' % (
				self.inputs[0].abspath(), <3>
				self.outputs[0].abspath()
			)
		)

class cat(Task):
	def run(self):
		return self.exec_command('cat %s %s > %s' % (
				self.inputs[0].abspath(),
				self.inputs[1].abspath(),
				self.outputs[0].abspath()
			)
		)

def build(ctx):

	cp_1 = cp(env=ctx.env) <4>
	cp_1.set_inputs(ctx.path.find_resource('wscript')) <5>
	cp_1.set_outputs(ctx.path.find_or_declare('foo.txt'))
	ctx.add_to_group(cp_1) <6>

	cp_2 = cp(env=ctx.env)
	cp_2.set_inputs(ctx.path.find_resource('wscript'))
	cp_2.set_outputs(ctx.path.find_or_declare('bar.txt'))
	ctx.add_to_group(cp_2)

	cat_1 = cat(env=ctx.env)
	cat_1.set_inputs(cp_1.outputs + cp_2.outputs)
	cat_1.set_outputs(ctx.path.find_or_declare('foobar.txt'))
	ctx.add_to_group(cat_1)
---------------

<1> Task class declaration
<2> Waf tasks have a method named *run* to generate the targets
<3> Instances of _waflib.Task.Task_ have input and output objects representing the files to use (Node objects)
<4> Create a new task instance manually
<5> Set input and output nodes
<6> Add the task to the build context for execution (but do not execute them immediately)

The execution output will be the following:

[source,shishell]
---------------
$ waf clean build <1>
'clean' finished successfully (0.003s)
Waf: Entering directory `/tmp/build_manual_tasks/build'
[1/3] cp: wscript -> build/foo.txt
[2/3] cp: wscript -> build/bar.txt
[3/3] cat: build/foo.txt build/bar.txt -> build/foobar.txt
Waf: Leaving directory `/tmp/build_manual_tasks/build'
'build' finished successfully (0.047s)

$ waf build <2>
Waf: Entering directory `/disk/comp/waf/docs/book/examples/build_manual_tasks/build'
Waf: Leaving directory `/disk/comp/waf/docs/book/examples/build_manual_tasks/build'
'build' finished successfully (0.007s)

$ echo " " >> wscript <3>

$ waf build
Waf: Entering directory `/disk/comp/waf/docs/book/examples/build_manual_tasks/build'
[1/3] cp: wscript -> build/foo.txt <4>
[2/3] cp: wscript -> build/bar.txt
[3/3] cat: build/foo.txt build/bar.txt -> build/foobar.txt
Waf: Leaving directory `/disk/comp/waf/docs/book/examples/build_manual_tasks/build'
'build' finished successfully (0.043s)
---------------

<1> The tasks are not executed in the _clean_ command
<2> The build keeps track of the files that were generated to avoid generating them again
<3> Modify one of the source files
<4> The dependency graph is causing a rebuild

Please remember:

. The execution order was computed automatically, by using the file inputs and outputs
. The dependencies were computed automatically (the files were rebuilt when necessary), by using the file contents (hashes of the file contents were stored between the builds and compared)
. The tasks that have no order constraints are executed in parallel by default

NOTE: Declaring the tasks directly is tedious and results in lengthy scripts. A more simple way of declaring tasks will be provided in the next section.

==== Task encapsulation

The build process is used to 

Since the Waf commands build, clean, install and uninstall execute the same function 'build', it is somehow necessary to isolate the declaration of the targets from the actual code that will create them. For example:

. Execution control: targets are only produced during the calls to the commands 'build' and 'install'
. Parallel target processing to accelerate the builds: multi-core systems
. Filesystem abstraction: fetching data from the network
. Extensibility: adding support for new compilers and new languages from user scripts
. Flexibility: changing the semantics of the declarations depending on the platform (operating system, compiler, etc)

image::build{PIC}["Build process overview"{backend@docbook:,width=110:}]


These main contraints lead to the creation of an abstraction layer between the actual code execution ('task') and the declaration ('task generators'). Here are two important definitions:

. `Task`: Abstract unit of data transformation which may be delegated for later execution. Task instances often present sequential constraints and require a scheduler to optimize the overall execution time (execution in parallel whenever possible).
. `Task generator`: Object part of the user interface (Waf scripts) used to create lots of task instances. The task generators handle global constraints across the tasks: access to the configuration sets, data sharing, operating system abstraction, error checking, etc

Here is a sample project script to illustrate the concepts:

[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	pass

def build(ctx):
	obj = ctx(target='test.txt', rule='touch ${TGT}')
	print('  ' + str(obj.__class__))
---------------

The call _ctx(...)_ is just a shortcut on the build context to create new task generator instances easily. The output will be the following:

[source,shishell]
---------------
$ waf distclean configure build build clean
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/smallproject/build'
  class 'TaskGen.task_gen' <1>
[1/1] test.txt:  -> build/test.txt <2>
Waf: Leaving directory `/tmp/smallproject/build'
'build' finished successfully (0.011s)
Waf: Entering directory `/tmp/smallproject/build'
  class 'TaskGen.task_gen' <3>
Waf: Leaving directory `/tmp/smallproject/build'
'build' finished successfully (0.004s)
  class 'TaskGen.task_gen' <4>
'clean' finished successfully (0.002s)
---------------

<1> Print _obj.__class___.
<2> Actual task execution, during the first build.
<3> This print was output during the second `build` execution. The target is considered up-to-date and is not rebuilt.
<4> This print was output during the call to `clean`.

=== Executing specific routines before or after the build

User functions may be bound to be executed at two key moments during the build command (callbacks):

. immediately before the build starts (bld.add_pre_fun)
. immediately after the build is completed successfully (bld.add_post_fun)

Here is how to execute a test after the build is finished:

[source,python]
---------------
top = '.'
out = 'build'

def options(ctx):
	ctx.add_option('--exe', action='store_true', default=False,
		help='execute the program after it is built')

def configure(ctx):
	pass

def pre(ctx): <1>
	print('before the build is started')

def post(ctx):
	print('after the build is complete')
	if ctx.cmd == 'install': <2>
		if ctx.options.exe: <3>
			ctx.exec_command('/sbin/ldconfig') <4>

def build(ctx):
	ctx.add_pre_fun(pre) <5>
	ctx.add_post_fun(post)
---------------

<1> The callbacks take the build context as unique parameter 'ctx'
<2> Access the command type
<3> Access to the command-line options
<4> A common scenario is to call ldconfig after the files are installed.
<5> Scheduling the functions for later execution. Remember that in Python, functions are objects too.

Upon execution, the following output will be produced:

[source,shishell]
---------------
waf distclean configure build install --exe
'distclean' finished successfully (0.005s)
'configure' finished successfully (0.011s)
Waf: Entering directory `/disk/comp/waf/docs/book/examples/build_2/build'
before the build is started <1>
Waf: Leaving directory `/disk/comp/waf/docs/book/examples/build_2/build'
after the build is complete <2>
'build' finished successfully (0.004s)
Waf: Entering directory `/disk/comp/waf/docs/book/examples/build_2/build'
before the build is started
Waf: Leaving directory `/disk/comp/waf/docs/book/examples/build_2/build'
after the build is complete
/sbin/ldconfig: Can't create temporary cache file /etc/ld.so.cache~: Permission denied <3>
'install' finished successfully (15.730s)
---------------

<1> output of the function bound by 'bld.add_pre_fun'
<2> output of the function bound by 'bld.add_post_fun'
<3> execution at installation time


////

==== Finding files and folders through node objects

In general, file system access are slow operations (listing files and folders, reading file permissions, etc). For this reason, Waf maintains an internal representation of the files and folders already explored in the form of a tree of Node instances. Two nodes may be accessed from the build context:

. `root`: node representing the root of the file system, or the folder containing the drive letters on win32 systems
. `path`: node representing the path of the script being read (path to the wscript file)

Nodes are often used for low-level operations such as extending Waf, and direct node manipulation is hardly ever necessary from user scripts.

[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	pass

def build(bld):
	print('current path %r' % bld.path)
	print('absolute path of the root node: %r' % bld.root.abspath())
	print('absolute path of the current node: %r' % bld.path.abspath())

	etc = bld.root.find_dir('/etc')
	var = bld.root.find_dir('/var')
	print('the node representing /etc %r: ' % etc)
	print('path from /var to /etc %r' % etc.relpath_gen(var))

	fstab = bld.root.find_resource('/etc/fstab')
	print('path to /etc/fstab: %r' % fstab.abspath())
---------------

The following results would be observed upon execution on a unix-like system:

[source,shishell]
---------------
$ waf distclean configure build
'distclean' finished successfully (0.002s)
'configure' finished successfully (0.001s)
Waf: Entering directory `/tmp/smallproject/build'
current path dir:///tmp/smallproject
absolute path of the root node: '/'
absolute path of the current node: '/tmp/smallproject'
the node representing /etc dir:///etc:
path from /var to /etc '../etc'
path to /etc/fstab: '/etc/fstab'
Waf: Leaving directory `/tmp/smallproject/build'
'build' finished successfully (0.003s)
---------------

Listing files and folders automatically reduces the needs for updating the scripts (files may be added, removed or renamed). A Node method called 'ant_glob' enables searching for folders and files on the file system. Here is an illustration:

[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	pass

def build(bld):
	print(bld.path.ant_glob('wsc*'))<1>
	print(bld.path.ant_glob('w?cr?p?'))<2>
	print(bld.root<3>.ant_glob('etc/**/g*'<4>, dir=True, src=False, bld=False)) <5>
---------------

<1> The method ant_glob is called on a node object, and not on the build context
<2> The patterns may contain wildcards such as * or ?, but they are http://ant.apache.org/manual/dirtasks.html[Ant patterns], not regular expressions
<3> Calling ant_glob on the file system root may be slow, and may give different results depending on the operating system
<4> The '**' indicates to consider folders recursively. Use with care.
<5> By default, only node representing source files are returned. It is possible to obtain folder nodes and build file nodes by turning on the appropriate options.

The execution output will be similar to the following:

[source,shishell]
---------------
$ waf
Waf: Entering directory `/tmp/smallproject/build'
wscript
wscript
etc/ghostscript etc/gconf etc/gconf/gconf.xml.mandatory etc/gnome-vfs-2.0 etc/gpm etc/gnupg etc/gre.d etc/gdm
Waf: Leaving directory `/tmp/smallproject/build'
'build' finished successfully (12.873s)
---------------

////

=== More build options

==== Installing files

Three build context methods are provided for installing files created during or after the build:

. install_files: install several files in a folder
. install_as: install a target with a different name
. symlink_as: create a symbolic link on the platforms that support it

[source,python]
---------------
def build(bld):
	bld.install_files('${PREFIX}/include', ['a1.h', 'a2.h']) <1>
	bld.install_as('${PREFIX}/dir/bar.png', 'foo.png') <2>
	bld.symlink_as('${PREFIX}/lib/libfoo.so.1', 'libfoo.so.1.2.3') <3>

	env_foo = bld.env.copy()
	env_foo.PREFIX = '/opt'
	bld.install_as('${PREFIX}/dir/test.png', 'foo.png', env=env_foo) <4>

	start_dir = bld.path.find_dir('src/bar')
	bld.install_files('${PREFIX}/share', ['foo/a1.h'],
		cwd=start_dir, relative_trick=True) <5>

	bld.install_files('${PREFIX}/share', start_dir.ant_glob('**/*.png'), <6>
		cwd=start_dir, relative_trick=True)
---------------

<1> Install various files in the target destination
<2> Install one file, changing its name
<3> Create a symbolic link
<4> Overridding the configuration set ('env' is optional in the three methods install_files, install_as and symlink_as)
<5> Install src/bar/foo/a1.h as seen from the current script into '$\{PREFIX}/share/foo/a1.h'
<6> Install the png files recursively, preserving the folder structure read from src/bar/

==== Listing the task generators and forcing specific task generators

The _list_ command is used to display the task generators that are declared:

// build_list
[source,python]
---------------
top = '.'
out = 'build'

def configure(ctx):
	pass

def build(ctx):
	ctx(source='wscript', target='foo.txt', rule='cp ${SRC} ${TGT}')
	ctx(target='bar.txt', rule='touch ${TGT}', name='bar')
---------------

By default, the name of the task generator is computed from the _target_ attribute:

[source,shishell]
---------------
$ waf configure list
'configure' finished successfully (0.005s)
foo.txt
bar
'list' finished successfully (0.008s)
---------------

The main usage of the name values is to force a partial build with the _--targets_ option. Compare the following:

[source,shishell]
---------------
$ waf clean build
'clean' finished successfully (0.003s)
Waf: Entering directory `/tmp/build_list/build'
[1/2] foo.txt: wscript -> build/foo.txt
[2/2] bar:  -> build/bar.txt
Waf: Leaving directory `/tmp/build_list/build'
'build' finished successfully (0.028s)

$ waf clean build --targets=foo.txt
'clean' finished successfully (0.003s)
Waf: Entering directory `/tmp/build_list/build'
[1/1] foo.txt: wscript -> build/foo.txt
Waf: Leaving directory `/tmp/build_list/build'
'build' finished successfully (0.022s)
---------------

==== Execution step by step for debugging (the _step_ command)

The _step_ is used to execute specific tasks and to return the exit status and any error message. It is particularly useful for debugging:

[source,shishell]
---------------
waf step --files=test_shlib.c,test_staticlib.c
Waf: Entering directory `/disk/comp/waf/demos/c/build'
c: shlib/test_shlib.c -> build/shlib/test_shlib.c.1.o
 -> 0
cshlib: build/shlib/test_shlib.c.1.o -> build/shlib/libmy_shared_lib.so
 -> 0
c: stlib/test_staticlib.c -> build/stlib/test_staticlib.c.1.o
 -> 0
cstlib: build/stlib/test_staticlib.c.1.o -> build/stlib/libmy_static_lib.a
 -> 0
Waf: Leaving directory `/disk/comp/waf/demos/c/build'
'step' finished successfully (0.201s)
---------------

In this case the +.so+ files were also rebuilt. Since the files attribute is interpreted a comma-separated list of regular expressions, the following will produce a different output:

[source,shishell]
---------------
$ waf step --files=test_shlib.c$
Waf: Entering directory `/disk/comp/waf/demos/c/build'
c: shlib/test_shlib.c -> build/shlib/test_shlib.c.1.o
 -> 0
Waf: Leaving directory `/disk/comp/waf/demos/c/build'
'step' finished successfully (0.083s)
---------------

Finally, the tasks to execute may be prefixed by 'in:' or 'out:' to specify if it is a source or a target file:

[source,shishell]
---------------
$ waf step --files=out:build/shlib/test_shlib.c.1.o
Waf: Entering directory `/disk/comp/waf-1.6/demos/c/build'
cc: shlib/test_shlib.c -> build/shlib/test_shlib.c.1.o
 -> 0
Waf: Leaving directory `/disk/comp/waf-1.6/demos/c/build'
'step' finished successfully (0.091s)
---------------

NOTE: when using _waf step_, all tasks are executed sequentially, even if some of them return a non-zero exit status

