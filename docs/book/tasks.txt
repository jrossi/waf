
== Task processing

This chapter provides a description of the task classes which are used during the build phase.

=== Task execution

==== Main actors

The build context is only used to create the tasks and to return lists of tasks that may be executed in parallel. The scheduling is delegated to a task producer which lets task consumers to execute the tasks. The task producer keeps a record of the build state such as the amount of tasks processed or the errors.

image::tasks_actors{PIC}["Actors processing the tasks"{backend@docbook:,width=150:},align="center"]

// To reduce the build time, it is interesting to take advantage of the hardware (multiple cpu cores) or of the environment (distributed builds).
The amount of consumers is determined from the number of processors, or may be set manually by using the '-j' option:

[source,shishell]
------------------
$ waf -j3
------------------

==== Build groups

The task producer iterates over lists of tasks returned by the build context. Although the tasks from a list may be executed in parallel by the consumer threads, all the tasks from one list must be consumed before processing another list of tasks. The build ends when there are no more tasks to process.

These lists of tasks are called _build groups_ and may be accessed from the build scripts. Let's demonstrate this behaviour on an example:

// tasks_groups
[source,python]
---------------
def build(ctx):
    for i in range(8):
        ctx(rule='cp ${SRC} ${TGT}', source='wscript', target='wscript_a_%d' % i,
            color='YELLOW', name='tasks a')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript_a_%d' % i, target='wscript_b_%d' % i,
            color='GREEN', name='tasks b')
    for i in range(8)
        ctx(rule='cp ${SRC} ${TGT}', source='wscript', target='wscript_c_%d' % i,
            color='BLUE', name='tasks c')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript_c_%d' % i, target='wscript_d_%d' % i,
            color='PINK', name='tasks d')
---------------

Each green task must be executed after one yellow task and each pink task must be executed after one blue task. Because there is only one group by default, the parallel execution will be similar to the following:

image::tasks_nogroup{PIC}["One build group"{backend@docbook:,width=420:},align="center"]

We will now modify the example to add one more build group.

[source,python]
---------------
def build(ctx):
    for i in range(8):
        ctx(rule='cp ${SRC} ${TGT}', source='wscript', target='wscript_a_%d' % i,
            color='YELLOW', name='tasks a')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript_a_%d' % i, target='wscript_b_%d' % i,
            color='GREEN', name='tasks b')
    ctx.add_group()
    for i in range(8):
        ctx(rule='cp ${SRC} ${TGT}', source='wscript', target='wscript_c_%d' % i,
            color='BLUE', name='tasks c')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript_c_%d' % i, target='wscript_d_%d' % i,
            color='PINK', name='tasks d')
---------------

Now a separator will appear between the group of yellow and green tasks and the group of blue and violet taks:

image::tasks_twogroups{PIC}["Two build groups"{backend@docbook:,width=400:},align="center"]

The tasks and tasks generator are added implicitely to the current group. By giving a name to the groups, it is easy to control what goes where:

// tasks_groups2
[source,python]
---------------
def build(ctx):

    ctx.add_group('group1')
    ctx.add_group('group2')

    for i in range(8):
        ctx.set_group('group1')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript', target='wscript_a_%d' % i,
            color='YELLOW', name='tasks a')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript_a_%d' % i, target='wscript_b_%d' % i,
            color='GREEN', name='tasks b')

        ctx.set_group('group2')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript', target='wscript_c_%d' % i,
            color='BLUE', name='tasks c')
        ctx(rule='cp ${SRC} ${TGT}', source='wscript_c_%d' % i, target='wscript_d_%d' % i,
            color='PINK', name='tasks d')
---------------

NOTE: Build groups prevent task parallelization and may cause longer build times.

==== The Producer-consumer system

In most python interpreters, a global interpreter lock prevents parallelization by more than one cpu core at a time. Therefore, it makes sense to restrict the task scheduling on a single task producer, and to let the threads access only the task execution.

The following illustrates the relationship between the task producers and consumers as performed during the build:

image::prodcons{PIC}["Parallel execution"{backend@docbook:,width=490:},align="center"]

==== Task states and status

A state is a assigned to the each task (_task.hasrun = state_) to keep track of the execution. The possible values are the following:

[options="header", cols="1,1,6"]
|=================
|State    | Numeric value | Description
|NOT_RUN  | 0 | The task has not been processed yet
|MISSING  | 1 | The task outputs are missing
|CRASHED  | 2 | The task method 'run' returned a non-0 value
|EXCEPTION| 3 | An exception occured in the Task method 'run'
|SKIPPED  | 8 | The task was skipped (it was up-to-date)
|SUCCESS  | 9 | The execution was successful
|=================

To decide to execute a task or not, the producer uses the value returned by the task method 'runnable_status'. The possible return values are the following:

[options="header", cols="1,6"]
|=================
|Code    | Description
| ASK_LATER | The task may depend on other tasks which have not finished to run (not ready)
| SKIP_ME   | The task does not have to be executed, it is up-to-date
| RUN_ME    | The task is ready to be executed
|=================

The following diagram represents the main task methods:

image::task_run{PIC}["Task states"{backend@docbook:,width=250:},align="center"]

=== Build order constraints

==== set_run_after

The method _set_run_after_ is used to declare ordering constraints between tasks:

[source,python]
---------------
task1.set_run_after(task2)
---------------

The tasks are stored in the attribute _run_after_ and are used by the method runnable_status to yield the status 'ASK_LATER' when a task has not run yet. This is merely for the build order and not for the dependencies.

==== computed constraints

===== after/before

The attributes _before_ and _after_ are used to declare ordering constraints between tasks:

[source,python]
---------------
from waflib import Task
class task_test_a(Task.TaskBase):
    before = 'task_test_b'
class task_test_b(Task.TaskBase):
    after = 'task_test_a'
---------------

===== ext_in/ext_out

Another way to declare precedence constraints is to declare a file extension production, for example:

[source,python]
---------------
from waflib import Task
class task_test_a(Task.TaskBase):
    ext_in = '.c'
class task_test_b(Task.TaskBase):
    ext_out = '.c'
---------------

The 'extensions' ext_in and ext_out have to match to add a valid precedence constraint, but they are only symbols in this context. They do not mean the tasks actually have to produce files of that type.

===== files inputs/outputs

Before feeding the tasks to the producer-consumer system, a constraint extraction is performed on the tasks having input and output files. The attributes _run_after_ are initialized with the tasks to wait for.

==== soft order constraints

Tasks that are known to take a lot of time may be launched first to improve the build times. The general problem of finding an optimal order for launching tasks in parallel and with constraints is called http://en.wikipedia.org/wiki/Job-shop_problem[Job Shop]. In practice this problem can often be reduced to a critical path problem (approximation).

The following pictures illustrate the difference in scheduling a build with different independent tasks, in which a slow task is clearly identified, and launched first:

image::duration-1{PIC}["Random order"{backend@docbook:,width=310:},align="center"]
image::duration-2{PIC}["Slowest task first"{backend@docbook:,width=310:},align="center"]

Waf provides a function for reordering the tasks before they are launched in the module Runner, the default reordering may be changed by dynamic method replacement in Python:

[source,python]
---------------
from waflib import Runner
def get_next(self):
    # reorder the task list by a random function
    self.outstanding.sort()
    # return the next task
    return self.outstanding.pop()
Runner.Parallel.get_next = get_next
---------------

If the reordering is not to be performed each time a task is retrieved, the list of task may be reordered when the next group is retrieved:

[source,python]
---------------
from waflib import Runner
old_refill = Runner.Parallel.refill_task_list
def refill_task_list(self):
    old_refill(self)
    self.outstanding.sort()
Runner.Parallel.refill_task_list = refill_task_list
---------------

It is possible to measure the task execution times by intercepting the function calls. The task execution times may be re-used for optimizing the schedule for subsequent builds:

[source,python]
---------------
import time
from waflib import Task
old_call_run = Task.TaskBase.call_run
def new_call_run(self):
    t1 = time.time()
    ret = old_call_run(self)
    t2 = time.time()
    if not ret: print("execution time %r" % (t2 - t1))
    return ret
Task.TaskBase.call_run = new_call_run
---------------


=== Dependencies

==== Task signatures

The direct instances of TaskBase are quite limited and do not track the changes to the source files. The class 'Task' provides the necessary features for the most common builds in which source files are used to produce target files. The idea is to create a unique signature for tasks, and to represent the dependencies on files or other tasks by including them in the signature. A hashing function is used for computing the signature, by default it is md5.

The following diagram illustrates the task processing including the signature, it is only valid for Task instance (not TaskBase instances):

image::task_signature{PIC}["Signatures"{backend@docbook:,width=320:},align="center"]

The signature computation uses the following data:

. explicit dependencies: input files and dependencies set explicitly using task.deps_man or bld.depends_on
. implicit dependencies: dependencies searched by the task itself (like source files included from other source files).
. parameters: compilation flags and command-line parameters.

Here is an example illustrating the different kinds of dependencies:

[source,python]
---------------
from waflib import Task
class task_demo(Task.Task):
    vars = ['CXXFLAGS', 'LINKFLAGS'] <1>
    def scan(self): <2>
        return [[self.inputs[0].parent.find_resource('.svn/entries')], []]

task = task_demo()
task.inputs = [bld.path.find_resource('test.cxx')] <3>
task.deps_man = [bld.path.find_resource('wscript')] <4>

bld.add_manual_dependency('main.c', 'an arbitrary string value') <5>
bld.add_manual_dependency(
        bld.path.find_or_declare('test_c_program'),
        bld.path.find_resource('bbb')) <6>
---------------

<1> Environment variable dependencies (compilation flags)
<2> Implicit dependencies: a method returns a list containing the list of additional nodes to take into account, and the list of the files that could not be found (cache)
<3> Explicit dependencies as input files (nodes)
<4> Explicit dependencies as manual dependencies
<5> Manual dependencies on source files, the second parameter can be a string, a node object or a function returning a string
<6> Manual dependencies with nodes, the first node represents a target (which may or may not exist in the build), and the second parameter represents a file in the source directory.

==== Explicit dependencies

TODO

==== Implicit dependencies and scanners

TODO

==== Variables

TODO


////
=== Task execution order

Running tasks in parallel is a simple problem, but in practice it is more complicated:
. Dependencies can be discovered during the build (dynamic task creation)
. New ordering constraints can be discovered after files are compiled
. The amount of tasks and ordering constraints (graph size) can be huge and performance may be a problem

To make the problem more simple, it is divided by the different concerns, and the ordering constraints can be given on three different levels:

. groups of tasks may run only after another group of tasks has finished to run, this represents a strict sequential order between groups of tasks, for example a compiler is produced and used to compile the tasks in the next group
. task types to indicate the instance will run after other task type instances, for example linking object files may only occur after compiling the source files
. specific constraints for task instances that can only run after a few other task instances

unlike the previous constraints, it is used on the instances of class 'Task' which is a subclass of class 'TaskBase'
////


