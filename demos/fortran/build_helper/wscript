#! /usr/bin/env python

top = '.'
out = 'build'

def options(opt):
	opt.load('compiler_c')
	opt.load('compiler_fc')

def configure(conf):
	conf.load('compiler_c')
	conf.load('compiler_fc')
	conf.check_fortran()
	conf.check_fortran_verbose_flag()
	conf.check_fortran_clib()

def build(bld):

	bld(
		features = 'fc typemap fcshlib',
		source = 'fsrc.f90 basetypes.f90',
		target = 'foo',
		name = 'orig_fsrc',
		)

	# bld.gen_type_map_files()

class ctp(object):
	def __init__(self, name, basetype, odecl, use):
		self.name = name
		self.basetype = basetype
		self.odecl = odecl
		self.use = use
		self.fc_type = None

# from waflib.Configure import conf

# @conf
def gen_type_map_files(self, *k, **kw):
	# The ctp properties (name, basetype, odecl, etc.) would be listed in a
	# configuration file and the ctp list below would be loaded from that file.
	# But the type resolution must be determined at *compile time* (i.e. build
	# time), and can't be determined by static analysis.  This is because each
	# fortran compiler can have a different value for the type resolution.
	# Moreover, the type resolution can depend on an arbitrary number of .mod
	# files and integer expressions.
	ctps = [ctp(name='int_arg_kind',
				basetype='integer',
				odecl='integer(kind=arg_kind)',
				use='example_mod')]

	# the 'use' line above uses the .mod file created after the compilation of
	# fsrc.f90.  The type mapping depends on the .mod file generated, and thus
	# the mapping needs to be discovered during the build stage, not the
	# configuration stage.

	find_types(self, ctps)

	# write fortran -> C mapping to file.
	write_type_map(self, ctps, 'type_maps.f90')

def find_types(self, ctps):
	for ctp in ctps:
		fc_type = None
		fc_type = find_fc_type(self, ctp.basetype,
					ctp.odecl, ctp.use)
		if not fc_type:
			raise RuntimeError(
					"unable to find C type for type %s" % ctp.odecl)
		ctp.fc_type = fc_type

type_dict = {'integer' : ['c_char', 'c_short', 'c_int', 'c_long']}

def find_fc_type(self, base_type, decl, use):
	fsrc_tmpl = '''\
subroutine outer(a)
  use, intrinsic :: iso_c_binding
  implicit none
  %(TEST_DECL)s, intent(inout) :: a
  interface
	subroutine inner(a)
	  use, intrinsic :: iso_c_binding
	  use %(USE)s
	  implicit none
	  %(TYPE_DECL)s, intent(inout) :: a
	end subroutine inner
  end interface
  call inner(a)
end subroutine outer
'''
	for ctype in type_dict[base_type]:
		test_decl = '%s(kind=%s)' % (base_type, ctype)
		fsrc = fsrc_tmpl % {'TYPE_DECL' : decl,
							'TEST_DECL' : test_decl,
							'USE' : use}
		try:
			self.check_cc(
					fragment=fsrc,
					compile_filename='test.f90',
					features='fc'
					)
		except self.errors.ConfigurationError:
			pass
		else:
			res = ctype
			break
	else:
		res = ''
	return res

def write_type_map(self, ctps, fname):
	nd = self.path.make_node(fname)
	nd.write('''\
module type_maps
use, intrinsic :: iso_c_binding
implicit none
''', flags='w')
	for ctp in ctps:
		nd.write('integer, parameter :: %s = %s\n' % (ctp.name, ctp.fc_type),
				flags='a')
	nd.write('end module type_maps\n', flags='a')

# ---- at the end it is really simple -_-

import os
from waflib import Logs, Build, Utils

from waflib import TaskGen, Task
@TaskGen.feature('typemap')
@TaskGen.after('apply_link')
def process_typemaps(self):
	node = self.path.find_resource(getattr(self, 'typemap', 'fwrap_ktp.in'))
	if not node:
		raise self.bld.errors.WafError('no typemap found for %r' % self)
	f90out = node.change_ext('.f90')
	lst = [node]
	for x in self.tasks:
		if x.inputs and x.inputs[0].name.endswith('.f90'):
			lst.append(x.inputs[0])
	tmtsk = self.typemap_task = self.create_task('modmap', lst, [f90out, node.change_ext('.h')])

	for x in self.tasks:
		if x.inputs and x.inputs[0].name.endswith('.f90'):
			tmtsk.set_run_after(x)

	tsk = self.create_compiled_task('fc', f90out)
	tsk.nomod = True # do not skip this
	self.link_task.inputs.append(tsk.outputs[0])

class modmap(Task.Task):
	"""dynamic tasks are fashionable"""
	ext_out = ['.h']
	def run(self):

		obld = self.generator.bld
		bld = Build.BuildContext(top_dir=obld.srcnode.abspath(), out_dir=obld.bldnode.abspath())
		bld.init_dirs()
		bld.in_msg = 1
		bld.all_envs['default'] = self.env.derive()
		node = self.inputs[0]
		bld.logger = Logs.make_logger(node.parent.get_bld().abspath() + os.sep + node.name + '.log', 'build')

		# so now you can perform configuration checks ...
		# NOTE there is a bug with the thread pool which may cause starvation...
		try:
			bld.check(header_name='stdio.h', features='cxx cprogram')
		except:
			pass

		for x in self.outputs:
			x.write('\tsubroutine foo\n\tend\n')

# vim:ft=python:noet
