#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2010 (ita)

VERSION='0.0.1'
APPNAME='cpp_gen'

top = '.'
out = 'build'

def options(opt):
	opt.load('compiler_cxx')

def configure(conf):
	conf.load('compiler_cxx')
	conf.check(header_name='stdio.h', features='cxx cxxprogram', mandatory=False)

def build(bld):
	bld.program(source='main.cpp a.cpp', target='app')

#--------

from waflib import Task, TaskGen, Utils
from waflib.Tools import cxx

@TaskGen.extension('.cpp')
def more_tasks_at_once(self, node):
   task1 = self.create_task('prog1', node, [])
   task2 = cxx.cxx_hook(self, node)

def cmpnodes(a, b):
	return cmp(a.abspath(), b.abspath())

class prog1(Task.Task):
	before=['cxxprogram', 'cxxshlib', 'cxxstlib']

	def runnable_status(self):
		for x in self.run_after:
			if not x.hasrun:
				return Task.ASK_LATER

		sig = self.signature()
		for x in self.generator.bld.raw_deps.get(sig, []):
			self.outputs.append(self.generator.bld.srcnode.find_node(x))

		#if not self.outputs:
		#	ret = Task.can_retrieve_cache(self)
		#	if ret:
		#		self.add_nodes()

		if self.outputs:
			tsk = cxx.cxx_hook(self.generator, self.outputs[0])
			self.generator.link_task.inputs.append(tsk.outputs[0])
			self.generator.link_task.inputs.sort(cmp=cmpnodes)

		ret = Task.Task.runnable_status(self)
		return ret

	def add_nodes(self):
		inp = self.inputs[0]
		node = inp.parent.get_bld().find_node(inp.name.replace('.cpp', '.ser.cpp'))
		if node:
			self.outputs = [node]
			h_node = inp.parent.find_node(inp.name.replace('.cpp', '.ser.h'))
			if h_node:
				self.outputs.append(h_node)

	def run(self):
		if self.inputs[0].name == 'a.cpp':
			# simulate the creation of an interface file
			out = self.inputs[0].parent.get_bld().make_node('a.ser.cpp')
			out.write('\n\n')

		self.add_nodes()
		if self.outputs:
			tsk = cxx.cxx_hook(self.generator, self.outputs[0])
			self.more_tasks = [tsk]
			self.generator.bld.raw_deps[self.signature()] = [x.path_from(self.generator.bld.srcnode) for x in self.outputs]
			self.generator.link_task.inputs.append(tsk.outputs[0])
			self.generator.link_task.inputs.sort(cmp=cmpnodes)
			self.generator.link_task.set_run_after(tsk)

			delattr(self, 'uid_') # necessary at the moment, as the task id depends on the outputs

	#def post_run(self):
	#	bld = self.generator.bld
	#	ret = Task.Task.post_run(self)
	#	if not bld.cache_global or bld.nocache or not self.outputs:
	#		return ret
	#	Task.put_files_cache(self)
	#	return ret

# normally a decorator but we may use it like this
#Task.cache_outputs(prog1)

